鲜花市场 AI 模型设计文档

版本：v1.0
覆盖范围：C1 → D → C2 → E → 特征工程（FE）→ A（短期价格预测）

0. 总体设计思路

整个模型体系围绕 “时间序列 + 行为特征 + 行情指数” 展开，采用分层管线方式构建：

C1 初步清洗：把显性的脏数据、单位问题和幽灵字段先清掉，得到“可用但不完美”的样本。

D 整天缺失补全：在时间序列维度补齐缺失日期，保证后续能构造滞后 / 滚动特征。

C2 强清洗（异常检测）：从时间序列角度标记并处理异常点，进一步提高数据质量。

E 花价指数：把全市场、品类、品种的 VWAP 指数算出来，作为“行情特征”加入。

特征工程（FE）：构造时间特征、价格/销量滞后特征、波动特征、指数特征和目标列。

A 短期价格预测模型：基于 LightGBM 的 1/2/3 日价格预测模型，并形成回测与未来推理脚本。

所有步骤都以 文件 + 脚本 为最小颗粒度：

每一步的输入、输出文件路径固定

每一步都有独立 run.py 入口，便于单步调试与流水线整合

1. C1 初步清洗（preliminary_cleaning）
1.1 目标

去掉后续完全不用、还会拖累 IO / 内存的 幽灵字段

统一单位（扎 → 支），修正显性错误取值

统一空值 / 文本规范，输出结构稳定的基础样本

1.2 所在模块 & 入口

模块路径：src/data_processing/preliminary_cleaning/

core.py：核心清洗逻辑

run.py：命令行入口

运行方式（项目根目录）：

python -m src.data_processing.preliminary_cleaning.run

1.3 输入

数据源：PostgreSQL 样本表 fm_market_price

关键字段（部分）：

ts：日期

product_id、variety、classify_name、grade、spec、color、shop_name

retail_price：零售价

volume：成交量

unit：单位（支 / 扎 / 其他）

1.4 核心清洗规则

删除幽灵字段（整个项目不再使用）

wholesale_price

image_url

images

ingest_at

单位统一（扎 → 支）

若 unit == "扎" 且 spec 能解析出“10枝/扎”等：

retail_price = retail_price / 枝数

volume = volume * 枝数

若 unit == "扎" 且 spec 缺失：

默认按 10 枝处理

最终 所有记录的单位都转为“支”，unit 字段同步更新。

数值 & 文本清洗

retail_price <= 0 或 volume < 0 的显性错误：置为缺失或剔除（视业务而定）

空字符串统一转为 NaN

retail_price 统一保留 2 位小数

字段类型规范

日期列：强制转为 datetime64[ns]

分类 / 文本列：保持为 object，留给 FE 阶段统一编码

1.5 输出

文件：data/processed/market_price_prelim_clean.csv

特点：

字段结构固定

单位全部为“支”

已删除幽灵字段

可直接作为 D 步输入

2. D 整天缺失补全（missing_value_filling）
2.1 目标

以“商品时间序列”为单位，补齐中间缺失的整天数据

保证后续可以稳定地构造 滞后特征 & 滚动窗口特征

显式标记哪些行、哪些字段是“补出来”的，便于后续使用或过滤

2.2 模块 & 入口

模块路径：src/data_processing/missing_value_filling/

core.py：补全核心逻辑

run.py：执行入口

d_filling_quality_report.py：补全质量 PDF 报告

运行方式：

python -m src.data_processing.missing_value_filling.run
# 质量报告：
python -m src.data_processing.missing_value_filling.d_filling_quality_report

2.3 输入

data/processed/market_price_prelim_clean.csv（C1 输出）

2.4 关键设计

时间索引 & 分组粒度

按以下字段组合为一个“商品时间序列”分组：

product_id + variety + spec + grade + shop_name + classify_name + color


对每个分组：

找到该分组的 ts_min 和 ts_max

只在 [ts_min, ts_max] 范围内进行日期补全
→ 不会在序列开始之前 / 结束之后瞎补

日期补全逻辑

以日频率（freq="D"）重建索引：
full_index = pd.date_range(ts_min, ts_max, freq="D")

用 reindex 把原数据映射到完整日期索引上

对新增的日期行，先生成空记录

数值字段插值

针对：

retail_price

volume

使用时间序列插值：

g_full["retail_price"] = g_full["retail_price"].interpolate(method="time", limit_area="inside")
g_full["volume"] = g_full["volume"].interpolate(method="time", limit_area="inside")


特点：

只对“中间缺口”插值（左右都有真实值）

不对序列开头 / 结尾进行外推

插值后：

retail_price：保留 2 位小数

volume：四舍五入转为整数（Int64）

静态字段前后填充

如 variety、grade、color 等静态属性：

使用 ffill().bfill() 填充，保证新增行不出现空值。

新增标记字段

is_synthetic_row：该行是否为 D 步新增（补全行）

is_filled_retail_price：价格是否由插值得到

is_filled_volume：成交量是否由插值得到

后续可以：

过滤掉补全行

或者在建模时把这些标记当作特征使用

2.5 输出

文件：data/processed/market_price_filled.csv

典型行数：从 ~44 万行补全到 ~57 万行

附带 reports/d_filling_quality_report.pdf 用于说明补全前后差异

3. C2 强清洗（异常检测 outlier_detection）
3.1 目标

在经过 C1 + D 处理后的平滑时间序列上，进一步识别异常点：

短时间内价格 / 成交量突变

与历史行为明显不一致的值

与同品类/全市场指数相比明显偏离的点

并为每一条记录打标，形成 高质量训练样本。

3.2 模块 & 入口

模块路径：src/data_processing/outlier_detection/

core.py：异常检测 & 清洗逻辑

run.py：执行入口

c2_outlier_quality_report.py：质量报告 PDF

运行方式：

python -m src.data_processing.outlier_detection.run
# 生成质量报告：
python -m src.data_processing.outlier_detection.c2_outlier_quality_report

3.3 输入

data/processed/market_price_filled.csv（D 输出）

3.4 异常检测策略

分组维度：同 D 步的商品时间序列分组。

价格异常检测

使用 滑动窗口 + Z-Score / IQR：

对每个分组内 retail_price：

计算滚动均值 / 标准差

对当前价计算 Z 分数：
z = (price - rolling_mean) / rolling_std

若 |z| > z_threshold（例如 3），视为异常

或辅以：

与自身 7 日均值对比变化率

与花价指数（E 步）涨跌对比

成交量异常检测

同理对 volume 做：

3σ 或 IQR

单日异常暴涨 / 暴跌的点标记出来

处理策略

为避免过度篡改历史数据，C2 以“标记为主，必要时轻度修正”：

对异常点价格 / 成交量，可以：

使用邻近值 / 窗口中位数替换

或者保留原值但加上异常标记列

当前版本主要是 标记型强清洗，方便后续在训练/分析时有选择地使用。

3.5 标记字段 & 输出

新增字段：

is_outlier_price：价格是否被判为异常（0/1）

is_outlier_volume：成交量是否被判为异常（0/1）

输出：

文件：data/processed/market_price_cleaned.csv

报告：reports/c2_outlier_quality_report.pdf

给出异常点占比、分布、案例序列图等。

4. E 花价指数（basic_analysis）
4.1 目标

在交易明细基础上，构建多层级的 加权平均价格指数（VWAP），作为行情特征输入模型：

全市场指数（all index）

品类指数（classify index）

品种指数（variety index）

指数收益率（index_return）

4.2 模块 & 入口

模块路径：src/basic_analysis/

price_index_core.py：指数计算逻辑

run.py：执行入口

运行方式：

python -m src.basic_analysis.run

4.3 输入

data/processed/market_price_cleaned.csv（C2 输出）

4.4 指数算法

VWAP（成交量加权平均价）

对某一层级（例如全市场）：

price_index(ts) = sum(price_i(ts) * volume_i(ts)) / sum(volume_i(ts))


层级维度

全市场：所有记录

品类级：按 classify_name 分组

品种级：按 variety 分组

收益率

对每条指数序列计算日度收益率：

df["index_return"] = df["price_index"].pct_change(fill_method=None)


用于衡量行情涨跌幅。

4.5 输出

文件：data/intermediate/indices/flower_price_index.csv
包含字段：

ts

level（all / classify / variety）

key（对应分类/品种名称）

price_index

index_return

用途：在 FE 阶段按 ts + 层级键 合并到明细数据中。

5. 特征工程（Feature Engineering）
5.1 目标

在 C2 清洗数据 + E 花价指数 的基础上，构造可供模型使用的特征矩阵：

时间 & 周期特征

历史价格 / 成交量滞后特征

滚动窗口统计特征

行情指数特征

未来标签（1/2/3 日）

类别映射表（方便线上服务）

5.2 模块 & 入口

模块路径：src/prediction_models/common/feature_engineering.py

运行方式：

python -m src.prediction_models.common.feature_engineering

5.3 输入

清洗数据：data/processed/market_price_cleaned.csv

花价指数：data/intermediate/indices/flower_price_index.csv

5.4 主要特征构造

时间特征

day_of_week（0-6）

is_weekend（周六日标记）

day_of_month

month

is_month_start / is_month_end

价格 & 成交量滞后特征

对每个商品时间序列构造：

price_lag_1, price_lag_2, price_lag_3, price_lag_7, price_lag_14, price_lag_30
volume_lag_1, volume_lag_2, volume_lag_3, volume_lag_7, volume_lag_14, volume_lag_30


滚动窗口统计特征

以 3/7/14/30 日为窗口，构造：

均值：price_ma_k, volume_ma_k

标准差：price_std_k, volume_std_k

变异系数：price_cv_k（std/mean）

行情指数特征

将 E 步结果按日期 / 品类 / 品种合并，构造：

index_all / index_all_return

index_classify / index_classify_return

index_variety / index_variety_return

目标列（Labels）

按日期偏移构造未来标签：

y_price_1d = retail_price.shift(-1)
y_price_2d = retail_price.shift(-2)
y_price_3d = retail_price.shift(-3)
# 成交量预测时则构造 y_volume_1d/2d/3d


尾部因 shift 产生的缺值行会在训练阶段自动剔除。

类别映射表

对 variety / classify_name / spec / grade / color / shop_name 等类别字段建立 ID 映射，输出：

data/intermediate/features/category_features.csv

便于模型 / 服务层统一编码。

5.5 输出

特征矩阵：
data/intermediate/features/time_series_features.csv

类别映射表：
data/intermediate/features/category_features.csv

特征数目前约 90+ 列，覆盖时间、行为、行情等多维信息。

6. A 短期价格预测（short_term_price_pred）
6.1 目标

基于 FE 输出的特征矩阵，分别训练：

1 日价格预测模型：预测明日价格

2 日价格预测模型：预测后日价格

3 日价格预测模型：预测大后日价格

并形成：

训练脚本

验证集回测脚本

评估报告 PDF

未来推理脚本（不依赖真实价格）

6.2 模块结构 & 入口

路径：src/prediction_models/short_term_price_pred/

model_train.py：模型训练（时间序列切分）

model_predict.py：验证集回测预测（生成 y_true vs y_pred）

model_predict_future.py：真实未来推理（只用特征，不看标签）

run.py：一键执行 FE → 训练 → 回测 → 评估（可选）

运行示例：

# 单独训练
python -m src.prediction_models.short_term_price_pred.model_train

# 验证集回测 & 生成预测结果 CSV
python -m src.prediction_models.short_term_price_pred.model_predict

# 生成模型评估 PDF
python -m src.prediction_models.common.model_evaluation

# 模拟“线上真实推理”（只用最新特征）
python -m src.prediction_models.short_term_price_pred.model_predict_future

6.3 训练策略

输入数据

data/intermediate/features/time_series_features.csv

时间序列切分

按 ts 排序

前 80% 作为训练集

后 20% 作为验证集

保证验证集时间段在训练集之后，避免“未来穿越”

模型算法

LightGBM 回归（LGBMRegressor）

关键参数（可调）：

n_estimators = 600
learning_rate = 0.05
num_leaves = 64
subsample = 0.8
colsample_bytree = 0.8
reg_alpha = 0.1
reg_lambda = 0.2
random_state = 42


类别特征处理

训练脚本中将 object 列统一 astype("category").cat.codes，生成整型编码

避免 dtype 问题，同时与未来推理方式保持一致

评估指标

在验证集上计算：

MAE

RMSE

MAPE

6.4 验证集表现（回测结果）

当前模型的典型表现：

horizon	N_valid	MAE	RMSE	MAPE	中位 APE	P90	P95
1 日	96,204	0.3761	1.4361	5.08%	2.75%	11.77%	17.33%
2 日	96,204	0.5982	1.9866	7.13%	4.62%	16.23%	21.44%
3 日	96,204	0.7422	2.4468	8.55%	5.93%	18.93%	24.20%

说明：

1 日预测精度可用于 采购决策 & 风控建议

2/3 日预测适合作为 趋势与风险预警参考

6.5 输出模型 & 报告

模型文件：

models/artifacts/price_model_v1/model_1d.pkl

models/artifacts/price_model_v1/model_2d.pkl

models/artifacts/price_model_v1/model_3d.pkl

以及默认：model.pkl（1 日）

元数据：

metadata_1d.json / metadata_2d.json / metadata_3d.json

汇总：metadata.json

预测结果：

验证集回测：data/output/price_prediction_result.csv

未来推理：data/output/price_forecast_future.csv

评估报告：

reports/price_model_eval_report.pdf

APE 分布

y_true vs y_pred 散点图

按价格区间的误差分析

时间序列对比案例