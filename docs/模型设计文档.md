鲜花市场 AI 模型设计文档

版本：v1.0
覆盖范围：C1 → D → C2 → E → 特征工程（FE）→ A（短期价格预测）

0. 总体设计思路

整个模型体系围绕 “时间序列 + 行为特征 + 行情指数” 展开，采用分层管线方式构建：

C1 初步清洗：把显性的脏数据、单位问题和幽灵字段先清掉，得到“可用但不完美”的样本。

D 整天缺失补全：在时间序列维度补齐缺失日期，保证后续能构造滞后 / 滚动特征。

C2 强清洗（异常检测）：从时间序列角度标记并处理异常点，进一步提高数据质量。

E 花价指数：把全市场、品类、品种的 VWAP 指数算出来，作为“行情特征”加入。

特征工程（FE）：构造时间特征、价格/销量滞后特征、波动特征、指数特征和目标列。

A 短期价格预测模型：基于 LightGBM 的 1/2/3 日价格预测模型，并形成回测与未来推理脚本。

所有步骤都以 文件 + 脚本 为最小颗粒度：

每一步的输入、输出文件路径固定

每一步都有独立 run.py 入口，便于单步调试与流水线整合

1. C1 初步清洗（preliminary_cleaning）
1.1 目标

去掉后续完全不用、还会拖累 IO / 内存的 幽灵字段

统一单位（扎 → 支），修正显性错误取值

统一空值 / 文本规范，输出结构稳定的基础样本

1.2 所在模块 & 入口

模块路径：src/data_processing/preliminary_cleaning/

core.py：核心清洗逻辑

run.py：命令行入口

运行方式（项目根目录）：

python -m src.data_processing.preliminary_cleaning.run

1.3 输入

数据源：PostgreSQL 样本表 fm_market_price

关键字段（部分）：

ts：日期

product_id、variety、classify_name、grade、spec、color、shop_name

retail_price：零售价

volume：成交量

unit：单位（支 / 扎 / 其他）

1.4 核心清洗规则

删除幽灵字段（整个项目不再使用）

wholesale_price

image_url

images

ingest_at

单位统一（扎 → 支）

若 unit == "扎" 且 spec 能解析出“10枝/扎”等：

retail_price = retail_price / 枝数

volume = volume * 枝数

若 unit == "扎" 且 spec 缺失：

默认按 10 枝处理

最终 所有记录的单位都转为“支”，unit 字段同步更新。

数值 & 文本清洗

retail_price <= 0 或 volume < 0 的显性错误：置为缺失或剔除（视业务而定）

空字符串统一转为 NaN

retail_price 统一保留 2 位小数

字段类型规范

日期列：强制转为 datetime64[ns]

分类 / 文本列：保持为 object，留给 FE 阶段统一编码

1.5 输出

文件：data/processed/market_price_prelim_clean.csv

特点：

字段结构固定

单位全部为“支”

已删除幽灵字段

可直接作为 D 步输入

2. D 整天缺失补全（missing_value_filling）
2.1 目标

以“商品时间序列”为单位，补齐中间缺失的整天数据

保证后续可以稳定地构造 滞后特征 & 滚动窗口特征

显式标记哪些行、哪些字段是“补出来”的，便于后续使用或过滤

2.2 模块 & 入口

模块路径：src/data_processing/missing_value_filling/

core.py：补全核心逻辑

run.py：执行入口

d_filling_quality_report.py：补全质量 PDF 报告

运行方式：

python -m src.data_processing.missing_value_filling.run
# 质量报告：
python -m src.data_processing.missing_value_filling.d_filling_quality_report

2.3 输入

data/processed/market_price_prelim_clean.csv（C1 输出）

2.4 关键设计

时间索引 & 分组粒度

按以下字段组合为一个“商品时间序列”分组：

product_id + variety + spec + grade + shop_name + classify_name + color


对每个分组：

找到该分组的 ts_min 和 ts_max

只在 [ts_min, ts_max] 范围内进行日期补全
→ 不会在序列开始之前 / 结束之后瞎补

日期补全逻辑

以日频率（freq="D"）重建索引：
full_index = pd.date_range(ts_min, ts_max, freq="D")

用 reindex 把原数据映射到完整日期索引上

对新增的日期行，先生成空记录

数值字段插值

针对：

retail_price

volume

使用时间序列插值：

g_full["retail_price"] = g_full["retail_price"].interpolate(method="time", limit_area="inside")
g_full["volume"] = g_full["volume"].interpolate(method="time", limit_area="inside")


特点：

只对“中间缺口”插值（左右都有真实值）

不对序列开头 / 结尾进行外推

插值后：

retail_price：保留 2 位小数

volume：四舍五入转为整数（Int64）

静态字段前后填充

如 variety、grade、color 等静态属性：

使用 ffill().bfill() 填充，保证新增行不出现空值。

新增标记字段

is_synthetic_row：该行是否为 D 步新增（补全行）

is_filled_retail_price：价格是否由插值得到

is_filled_volume：成交量是否由插值得到

后续可以：

过滤掉补全行

或者在建模时把这些标记当作特征使用

2.5 输出

文件：data/processed/market_price_filled.csv

典型行数：从 ~44 万行补全到 ~57 万行

附带 reports/d_filling_quality_report.pdf 用于说明补全前后差异

3. C2 强清洗（异常检测 outlier_detection）
3.1 目标

在经过 C1 + D 处理后的平滑时间序列上，进一步识别异常点：

短时间内价格 / 成交量突变

与历史行为明显不一致的值

与同品类/全市场指数相比明显偏离的点

并为每一条记录打标，形成 高质量训练样本。

3.2 模块 & 入口

模块路径：src/data_processing/outlier_detection/

core.py：异常检测 & 清洗逻辑

run.py：执行入口

c2_outlier_quality_report.py：质量报告 PDF

运行方式：

python -m src.data_processing.outlier_detection.run
# 生成质量报告：
python -m src.data_processing.outlier_detection.c2_outlier_quality_report

3.3 输入

data/processed/market_price_filled.csv（D 输出）

3.4 异常检测策略

分组维度：同 D 步的商品时间序列分组。

价格异常检测

使用 滑动窗口 + Z-Score / IQR：

对每个分组内 retail_price：

计算滚动均值 / 标准差

对当前价计算 Z 分数：
z = (price - rolling_mean) / rolling_std

若 |z| > z_threshold（例如 3），视为异常

或辅以：

与自身 7 日均值对比变化率

与花价指数（E 步）涨跌对比

成交量异常检测

同理对 volume 做：

3σ 或 IQR

单日异常暴涨 / 暴跌的点标记出来

处理策略

为避免过度篡改历史数据，C2 以“标记为主，必要时轻度修正”：

对异常点价格 / 成交量，可以：

使用邻近值 / 窗口中位数替换

或者保留原值但加上异常标记列

当前版本主要是 标记型强清洗，方便后续在训练/分析时有选择地使用。

3.5 标记字段 & 输出

新增字段：

is_outlier_price：价格是否被判为异常（0/1）

is_outlier_volume：成交量是否被判为异常（0/1）

输出：

文件：data/processed/market_price_cleaned.csv

报告：reports/c2_outlier_quality_report.pdf

给出异常点占比、分布、案例序列图等。

4. E 花价指数（basic_analysis）
4.1 目标

在交易明细基础上，构建多层级的 加权平均价格指数（VWAP），作为行情特征输入模型：

全市场指数（all index）

品类指数（classify index）

品种指数（variety index）

指数收益率（index_return）

4.2 模块 & 入口

模块路径：src/basic_analysis/

price_index_core.py：指数计算逻辑

run.py：执行入口

运行方式：

python -m src.basic_analysis.run

4.3 输入

data/processed/market_price_cleaned.csv（C2 输出）

4.4 指数算法

VWAP（成交量加权平均价）

对某一层级（例如全市场）：

price_index(ts) = sum(price_i(ts) * volume_i(ts)) / sum(volume_i(ts))


层级维度

全市场：所有记录

品类级：按 classify_name 分组

品种级：按 variety 分组

收益率

对每条指数序列计算日度收益率：

df["index_return"] = df["price_index"].pct_change(fill_method=None)


用于衡量行情涨跌幅。

4.5 输出

文件：data/intermediate/indices/flower_price_index.csv
包含字段：

ts

level（all / classify / variety）

key（对应分类/品种名称）

price_index

index_return

用途：在 FE 阶段按 ts + 层级键 合并到明细数据中。

5. 特征工程（Feature Engineering）
5.1 目标

在 C2 清洗数据 + E 花价指数 的基础上，构造可供模型使用的特征矩阵：

时间 & 周期特征

历史价格 / 成交量滞后特征

滚动窗口统计特征

行情指数特征

未来标签（1/2/3 日）

类别映射表（方便线上服务）

5.2 模块 & 入口

模块路径：src/prediction_models/common/feature_engineering.py

运行方式：

python -m src.prediction_models.common.feature_engineering

5.3 输入

清洗数据：data/processed/market_price_cleaned.csv

花价指数：data/intermediate/indices/flower_price_index.csv

5.4 主要特征构造

时间特征

day_of_week（0-6）

is_weekend（周六日标记）

day_of_month

month

is_month_start / is_month_end

价格 & 成交量滞后特征

对每个商品时间序列构造：

price_lag_1, price_lag_2, price_lag_3, price_lag_7, price_lag_14, price_lag_30
volume_lag_1, volume_lag_2, volume_lag_3, volume_lag_7, volume_lag_14, volume_lag_30


滚动窗口统计特征

以 3/7/14/30 日为窗口，构造：

均值：price_ma_k, volume_ma_k

标准差：price_std_k, volume_std_k

变异系数：price_cv_k（std/mean）

行情指数特征

将 E 步结果按日期 / 品类 / 品种合并，构造：

index_all / index_all_return

index_classify / index_classify_return

index_variety / index_variety_return

目标列（Labels）

按日期偏移构造未来标签：

y_price_1d = retail_price.shift(-1)
y_price_2d = retail_price.shift(-2)
y_price_3d = retail_price.shift(-3)
# 成交量预测时则构造 y_volume_1d/2d/3d


尾部因 shift 产生的缺值行会在训练阶段自动剔除。

类别映射表

对 variety / classify_name / spec / grade / color / shop_name 等类别字段建立 ID 映射，输出：

data/intermediate/features/category_features.csv

便于模型 / 服务层统一编码。

5.5 输出

特征矩阵：
data/intermediate/features/time_series_features.csv

类别映射表：
data/intermediate/features/category_features.csv

特征数目前约 90+ 列，覆盖时间、行为、行情等多维信息。

6. A 短期价格预测（short_term_price_pred）
6.1 目标

基于 FE 输出的特征矩阵，分别训练：

1 日价格预测模型：预测明日价格

2 日价格预测模型：预测后日价格

3 日价格预测模型：预测大后日价格

并形成：

训练脚本

验证集回测脚本

评估报告 PDF

未来推理脚本（不依赖真实价格）

6.2 模块结构 & 入口

路径：src/prediction_models/short_term_price_pred/

model_train.py：模型训练（时间序列切分）

model_predict.py：验证集回测预测（生成 y_true vs y_pred）

model_predict_future.py：真实未来推理（只用特征，不看标签）

run.py：一键执行 FE → 训练 → 回测 → 评估（可选）

运行示例：

# 单独训练
python -m src.prediction_models.short_term_price_pred.model_train

# 验证集回测 & 生成预测结果 CSV
python -m src.prediction_models.short_term_price_pred.model_predict

# 生成模型评估 PDF
python -m src.prediction_models.common.model_evaluation

# 模拟“线上真实推理”（只用最新特征）
python -m src.prediction_models.short_term_price_pred.model_predict_future

6.3 训练策略

输入数据

data/intermediate/features/time_series_features.csv

时间序列切分

按 ts 排序

前 80% 作为训练集

后 20% 作为验证集

保证验证集时间段在训练集之后，避免“未来穿越”

模型算法

LightGBM 回归（LGBMRegressor）

关键参数（可调）：

n_estimators = 600
learning_rate = 0.05
num_leaves = 64
subsample = 0.8
colsample_bytree = 0.8
reg_alpha = 0.1
reg_lambda = 0.2
random_state = 42


类别特征处理

训练脚本中将 object 列统一 astype("category").cat.codes，生成整型编码

避免 dtype 问题，同时与未来推理方式保持一致

评估指标

在验证集上计算：

MAE

RMSE

MAPE

6.4 验证集表现（回测结果）

当前模型的典型表现：

horizon	N_valid	MAE	RMSE	MAPE	中位 APE	P90	P95
1 日	96,204	0.3761	1.4361	5.08%	2.75%	11.77%	17.33%
2 日	96,204	0.5982	1.9866	7.13%	4.62%	16.23%	21.44%
3 日	96,204	0.7422	2.4468	8.55%	5.93%	18.93%	24.20%

说明：

1 日预测精度可用于 采购决策 & 风控建议

2/3 日预测适合作为 趋势与风险预警参考

6.5 输出模型 & 报告

模型文件：

models/artifacts/price_model_v1/model_1d.pkl

models/artifacts/price_model_v1/model_2d.pkl

models/artifacts/price_model_v1/model_3d.pkl

以及默认：model.pkl（1 日）

元数据：

metadata_1d.json / metadata_2d.json / metadata_3d.json

汇总：metadata.json

预测结果：

验证集回测：data/output/price_prediction_result.csv

未来推理：data/output/price_forecast_future.csv

评估报告：

reports/price_model_eval_report.pdf

APE 分布

y_true vs y_pred 散点图

按价格区间的误差分析

时间序列对比案例

7. B 成交量预测（volume_pred）

7.1 目标

在已有的价格预测能力基础上，构建 1/2/3 日 成交量预测模型，用于支撑后续 F 步的动态采购决策（给出「买多少」）。
核心目标：

预测未来 1 日 / 2 日 / 3 日 的成交量：

y_volume_1d：次日成交量

y_volume_2d：未来两日成交量

y_volume_3d：未来三日成交量

利用 量价联动关系：在业务上，成交量会受到价格预期的明显影响；

在不「偷看未来」的前提下，对比两种方案：

方案 A：使用“预测价格”作为前视特征；

方案 B：只使用历史特征，作为基线模型（baseline）。

7.2 模块结构与入口

模块路径：src/prediction_models/volume_pred/

model_train_A.py：方案 A 训练脚本（使用预测价格特征）

model_train_B.py：方案 B 训练脚本（仅历史特征）

model_predict_A.py：方案 A 验证集回测预测

model_predict_B.py：方案 B 验证集回测预测

run.py：可选的一键执行入口（按需扩展）

volume_model_evaluation.py：A/B 对比评估脚本，生成完整 PDF 报告

运行示例（项目根目录）：

# 方案 A 训练
python -m src.prediction_models.volume_pred.model_train_A

# 方案 B 训练
python -m src.prediction_models.volume_pred.model_train_B

# 生成 A/B 验证集预测结果
python -m src.prediction_models.volume_pred.model_predict_A
python -m src.prediction_models.volume_pred.model_predict_B

# 生成成交量预测评估报告 PDF
python -m src.prediction_models.volume_pred.volume_model_evaluation


7.3 输入数据与特征来源

基础特征矩阵：

文件：data/intermediate/features/time_series_features.csv

来源：前面的 FE 步骤输出，包含：

时间特征（周几 / 月份 / 是否周末等）

价格 / 成交量滞后特征（lag 1/2/3/7/14/30）

滚动窗口统计特征（均值 / 标准差 / 变异系数等）

花价指数特征（全市场 / 品类 / 品种指数与收益率）

目标列（Volume Labels）：

在 FE 或 volume 模块中按日期偏移构造：

y_volume_1d = volume.shift(-1)

y_volume_2d = volume.shift(-2)

y_volume_3d = volume.shift(-3)

尾部因 shift 产生缺失的行，在训练阶段剔除。

7.4 方案 A：使用预测价格的成交量模型

7.4.1 设计思路

方案 A 通过将 价格预测结果 注入特征矩阵，显式建模「量价联动」：

先基于 A 模块训练并得到价格预测结果：

data/output/price_prediction_result.csv（包含 ts/商品维度 + pred_price_1d/2d/3d 等列）。

调用注入脚本，将预测价格加入特征文件：

模块：src/prediction_models/common/inject_pred_price_feature.py

功能：按 ts + 商品分组字段 将 pred_price_1d/2d/3d 合并到 time_series_features.csv 中，生成额外特征：

pred_price_1d、pred_price_2d、pred_price_3d

在增强后的特征矩阵基础上训练成交量模型。

核心理念：

价格是成交量的重要驱动因素，尤其在价格波动较大、敏感品类上表现明显；

通过使用“模型预测价格”而不是“真实未来价格”，保证训练 / 推理口径与线上场景一致，不发生「偷看未来」。

7.4.2 训练策略

与价格模型保持一致的时间序列切分：

按 ts 排序；

前 80% 时间段作为训练集，后 20% 作为验证集；

保证验证集时间在训练集之后，避免数据泄露。

模型算法：

同样采用 LightGBM 回归（LGBMRegressor），关键参数与价格模型整体保持一致，便于后续统一管理；

对所有类别型字段进行编码（astype("category").cat.codes），与 A 模块保持一致。

7.4.3 输出与文件组织

模型文件（方案 A）：

models/artifacts/volume_model_A/model_1d.pkl

models/artifacts/volume_model_A/model_2d.pkl

models/artifacts/volume_model_A/model_3d.pkl

元数据（方案 A）：

models/artifacts/volume_model_A/metadata_1d.json

models/artifacts/volume_model_A/metadata_2d.json

models/artifacts/volume_model_A/metadata_3d.json

验证集预测结果（方案 A）：

data/output/volume_prediction_result_A.csv

竖表结构（long format），包含：

ts、product_id 等维度字段

horizon（1/2/3）

y_true、y_pred、abs_error、ape 等

7.5 方案 B：仅使用历史特征的基线模型

7.5.1 设计思路

方案 B 不引入任何「未来信息」，只使用 历史价格 / 成交量 / 指数等特征 做预测，用于作为业务上和算法上的对照基线（benchmark）：

优点：

结构更简单，解释性强；

不依赖价格预测结果，减少上游模型误差传导。

用途：

对比评估「预测价格特征」是否带来显著提升；

在部分场景下作为 fallback 模型（例如价格模型不可用时）。

7.5.2 训练策略

输入数据：

使用未注入预测价格前的特征矩阵（或忽略 pred_price_* 列）

时间切分策略、LightGBM 参数设置与方案 A 遵循同一口径。

输出文件（方案 B）：

模型文件：

models/artifacts/volume_model_B/model_1d.pkl

models/artifacts/volume_model_B/model_2d.pkl

models/artifacts/volume_model_B/model_3d.pkl

元数据：

models/artifacts/volume_model_B/metadata_1d.json 等

验证集预测结果（宽表形式）：

data/output/volume_prediction_result_B.csv

每条记录包含：

ts、product_id 等字段

y_volume_1d/2d/3d（真实成交量标签）

pred_volume_1d_B/2d_B/3d_B（方案 B 预测值）

7.6 评估与对比：volume_model_evaluation

7.6.1 评估脚本

路径：src/prediction_models/volume_pred/volume_model_evaluation.py

功能：读取 A/B 两种方案的预测结果文件，自动适配不同表结构（A：竖表；B：宽表），生成一份完整 PDF 报告：

输入：

data/output/volume_prediction_result_A.csv

data/output/volume_prediction_result_B.csv

输出：

reports/volume_model_eval_report.pdf

7.6.2 指标体系

对于每个预测期 H1/H2/H3（1/2/3 日）同时计算：

N：样本数

MAPE：平均绝对百分比误差

RMSE：均方根误差

R2：拟合优度

APE：逐样本绝对百分比误差序列（用于后续作图）

7.6.3 报告内容结构

（1）概览页

展示 H1/H2/H3 在 A/B 方案下的 N / MAPE / RMSE / R2 对比；

便于一眼看出哪种方案整体更优、哪个 horizon 更稳。

（2）每个 horizon 的详细分析页

对 H1/H2/H3 分别生成多页图表，包括：

散点图：

真实成交量 vs 预测成交量（A & B），带 y=x 参考线；

同时截断极端值（例如 99 分位），避免少数异常点影响观感。

误差分布图（APE 直方图）：

展示 A/B 的 APE 分布；

给出 P90/P95 等分位数，反映尾部误差情况。

时间序列趋势对比：

按天聚合成交量：真实 vs A 预测 vs B 预测；

用于观察在节假日/高峰期的整体趋势拟合情况。

按成交量分桶的 MAPE 条形图：

按真实成交量四分位数划分为：低 / 中低 / 中高 / 高 四档；

对比每一档中 A/B 的 MAPE，特别关注「高成交量」桶的表现。

按商品维度的 TopN 误差榜：

以 product_id 为粒度聚合，计算：N / MAPE_A / MAPE_B / DIFF(B-A)；

过滤掉样本数过少的商品（如 < 30），展示 A 相对 B 提升最大的 TopN；

帮助发现哪些关键品种最受益于“预测价格”特征，哪些品种仍需专项优化。

（3）结论页

对 H1/H2/H3 分别给出一句话结论：

哪个方案整体 MAPE 更低；

R2 对比情况；

对业务使用场景给出建议（例如：日常采购优先使用 A，部分敏感场景保留 B 作为对照）。

（4）方法与口径说明页

说明样本时间范围、时间切分方式；

指标定义（MAPE / RMSE / R2）；

分桶与分组逻辑（按成交量四分位 / 按 product_id）；

以及在极端行情、节假日场景中需要结合业务规则进行干预的原则。

7.7 与 F 步「动态采购建议」的衔接

F 步的采购建议模块（src/business_decision/) 会同时使用：

A 模块的未来价格预测；

B 模块（这里的 Volume Prediction）的未来成交量预测；

成交量预测结果提供「需求侧」信息，价格预测提供「成本与行情」信息，两者共同决定：

采购量建议（suggested_purchase_volume）；

风险提示（如预测需求大但价格高、或预测需求低但价格极低可囤货等）；

后续还可以叠加库存、损耗率、保鲜期等约束，构建完整的采购优化模型。
8. F 动态采购建议（business_decision）

✅ 建议追加内容（整段贴到文档末尾即可）
8. F 动态采购建议（business_decision）

8.1 目标

在已经具备「未来价格预测（A）」和「未来成交量 / 需求预测（B）」能力的基础上，结合库存、保鲜期、预算和业务规则，形成对每个 SKU 的**动态采购建议**，输出给业务侧作为每日进货参考。

核心目标：

- 给出「买多少」：每个 SKU 建议采购量（支数/扎数）
- 给出「怎么买」：高价谨慎、低价适度多买、考虑保鲜期与库存周转
- 给出「怎么解释」：为每个建议附带人类可读的决策说明，方便运营/老板理解与质疑

F 步同时输出两类结果：

- 机器可读的采购建议明细 CSV / Excel（按 SKU 列出）
- 管理层可读的汇总 & 风险提示 PDF（运营周报风格，可扩展）

---

8.2 模块结构与入口

模块路径：

- `src/business_decision/procurement_core.py`：采购建议核心算法
- `src/business_decision/procurement_report.py`：业务友好版汇总 & 报表导出（Excel/PDF）
- `src/business_decision/run.py`：一键执行入口

运行方式（项目根目录）：

```bash
python -m src.business_decision.run
# 生成业务友好版 Excel / PDF 报告：
python -m src.business_decision.procurement_report


8.3 输入数据与依赖

F 步依赖以下数据源：

价格预测结果（A 步输出）

文件：data/output/price_prediction_result.csv

主要字段：

ts：预测基准日期

商品维度字段：product_id, variety, classify_name, grade, spec, color, shop_name, market_name, place

horizon：预测期（1/2/3）

y_true（若为回测）、y_pred（价格预测值）

在 F 步中使用 y_pred 构造：

y_price_1d_pred：明日价格预测

y_price_3d_pred：未来 3 日价格预测（视业务需要）

成交量 / 需求预测结果（B 步输出）

方案 A：data/output/volume_prediction_result_A.csv（竖表）

方案 B：data/output/volume_prediction_result_B.csv（宽表）

F 步目前以 A 方案为主（可配置），通过统一适配逻辑得到：

y_volume_1d_pred：次日预测成交量

y_volume_3d_pred：未来 3 日预测成交量

同步保留真实历史量 volume 便于做覆盖天数等计算。

库存 / 在途库存信息

优先从本地或远程 PostgreSQL 读取库存表（若存在）：

字段示例：stock_on_hand（现有库）、stock_in_transit（在途量）

若暂未接入正式库存系统：

F 步会在运行时提示

自动退化为「0 库存假设」，相当于完全依赖预测需求给出建议。

基础商品维度与规格信息

来自前面清洗后的数据（market_price_cleaned）与特征文件：

unit：单位（支/扎）

spec：规格（如 10枝/扎）

classify_name：品类（玫瑰/康乃馨等）

grade、color、place 等结构信息

8.4 核心设计思路

F 步的核心逻辑分为三层约束：

需求视角：未来 N 天要卖多少？

使用 B 步的 y_volume_3d_pred 作为未来 3 日需求估计

计算平均日需求 avg_daily_demand

库存 & 安全库存视角：应该备多少货？

目标覆盖天数 = 规划天数 + 安全库存天数

再由保鲜期 / 品类保质天数进行限制（不能囤过久）

通过 stock_on_hand + stock_in_transit 与目标库存水平对比，得到初步建议采购量

业务规则视角：能买多少 / 值不值得买？

规格粒度约束（按扎数/箱数向上取整）

最小采购量门槛（太少不买，避免零碎采购）

预算约束（按全场预算削减，优先留给缺货风险高的 SKU）

价格信号约束（高价谨慎，低价适度偏多）

8.5 单 SKU 采购量计算逻辑

在 procurement_core.py 中，compute_procurement_for_row() 对每条 SKU 记录执行以下步骤（伪代码逻辑）：

计算未来需求

从预测结果取：

forecast_demand_1d = y_volume_1d_pred

forecast_demand_3d = y_volume_3d_pred

计算：

avg_daily_demand = forecast_demand_3d / PLANNING_DAYS

其中 PLANNING_DAYS 默认 3 天，可在配置中修改。

确定目标覆盖天数

基础覆盖天数：PLANNING_DAYS

安全天数：SAFETY_DAYS（如 0.5 天）

品类保鲜期约束：

通过 classify_name 调用 _get_max_coverage_days()，给出最大可覆盖天数（如玫瑰 3 天、菊花 5 天等）

最终目标覆盖天数：

target_coverage_days = min(PLANNING_DAYS + SAFETY_DAYS, max_days_by_shelf_life)

计算目标库存水平

required_stock_level = avg_daily_demand * target_coverage_days

考虑现有库存

available_stock = stock_on_hand + stock_in_transit

初步建议采购量：

raw_purchase_qty = required_stock_level - available_stock

不允许为负：

recommended_purchase_qty = max(raw_purchase_qty, 0)

按规格与最小采购量校正

从 spec 字段中解析每扎枝数，得到 pack_size（例如 10 支/扎）

采购量向上取整到整扎：

bundles = ceil(recommended_purchase_qty / pack_size)

purchase_qty_rounded = bundles * pack_size

若 purchase_qty_rounded < MIN_PURCHASE_QTY 则置为 0，避免零碎采购。

价格信号与决策说明

若存在 y_price_1d_pred 与近期均价 recent_avg_price：

计算 ratio = y_price_1d_pred / recent_avg_price

若 ratio > HIGH_PRICE_TH（如 1.05）：标记为 high_price_cautious

若 ratio < LOW_PRICE_TH（如 0.95）：标记为 low_price_buy_more

同时生成可读的 decision_reason 文案，如：

“库存+在途足以覆盖未来 3.5 天需求，无需采购”

“未来 3 天需求较高且库存偏低，建议采购 XX 支（按 10 支/扎向上取整）”

函数最终为该行写入以下关键字段：

forecast_demand_1d / forecast_demand_3d

avg_daily_demand

required_stock_level

recommended_purchase_qty（连续值）

purchase_qty_rounded（实际建议采购量）

price_signal

decision_reason

8.6 预算约束与全局优化

在计算完所有 SKU 的 purchase_qty_rounded 后，apply_budget_constraint() 会在全局层面套一层预算约束：

计算每个 SKU 的预估采购成本：

unit_price = y_price_1d_pred

est_cost = unit_price * purchase_qty_rounded

计算总成本 total_cost：

若 total_cost <= DAILY_BUDGET：预算充足，不做调整；

若超出预算：

计算每个 SKU 的优先级：

priority_score = forecast_demand_3d / (stock_on_hand + 1)

即：需求越大、库存越少，优先级越高。

按优先级排序，依次分配预算：

若预算足够覆盖当前 SKU 的全部建议采购量，则保留不变；

若预算不足，则按 spec 解析出的 pack_size 向下取整到整扎；

若调整后量低于 MIN_PURCHASE_QTY，则最终不采购。

该过程确保：

在预算有限的情况下，优先保障高缺货风险 SKU；

同时保持「按扎采购」和「最小采购量」的业务规则。

8.7 输出结果与业务友好版报表

F 步目前输出两类结果：

机器友好版采购明细（CSV）

文件：data/output/procurement_suggestion.csv

典型字段：

基础维度：run_date, ts, product_id, variety, classify_name, grade, spec, color, place, shop_name, market_name

预测信息：forecast_demand_1d, forecast_demand_3d, y_price_1d_pred, y_price_3d_pred

库存信息：stock_on_hand, stock_in_transit

决策结果：purchase_qty_rounded, price_signal, decision_reason

风险标签（可扩展）：如 shortage_risk_flag, overstock_risk_flag

业务友好版采购报告（Excel / PDF）

模块：procurement_report.py

主要输出：

汇总表（按品类、门店、产地等）：

未来需求、当前库存、建议采购量、金额占比

「异常提醒」栏（如预测误差高、价格异常波动等）

采购明细表（面向采购/运营）：

以 variety + grade + product_id 为主导线索，配合 spec / shop_name / place

字段示例：

品类(classify_name)、品种(variety)、等级(grade)、商品ID(product_id)、规格(spec)、颜色(color)、店铺(shop_name)、预测需求、建议采购量、预测价格、价格信号、备注

管理层总览页（PDF，可扩展）：

总采购量与总金额

按品类的采购占比饼图/柱状图

按门店/区域的需求分布

重点风险提示（如某类花大幅涨价但需求仍然旺盛）

8.8 与后续「产业指数 / 行为特征」模块的衔接展望（预留）

未来版本中，F 步可进一步与以下模块深度联动：

行为特征学习（behavior_feature_learning）：

把「门店进货行为模式」「品类季节性特征」注入到需求预测和采购决策中；

鲜花产业指数（industry_index）」：

利用 F 步的采购建议数据，构建行业层面的「供需紧张指数」「库存安全指数」「风险指数」，形成每日/每周产业指数报告。

当前文档版本专注于 C1→D→C2→E→FE→A→B→F 的完整闭环，实现从「原始交易数据」到「可执行采购建议」的一站式 AI 决策能力。